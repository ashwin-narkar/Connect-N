# Connect-N

Connect N was one of my most challenging CS projects. It involved implemting a fully scalable version of Connect 4 as well as a AI using the minimax algorithm. 

Description of Implementation of classes

Scaffold.cpp
  The scaffold is the board that is used to play connect n. It is designed using a two dimensional vector. Its constructor takes in the number of columns and rows that the user provides. The positions in the scaffold start at 1 and go to the number of rows/columns. There are two accessor functions to get the number of levels and columns. The checkerAt function returns the value of the checker at a given position. This given position is with respect to the implementation so checkerAt(0,0) is invalid because the rows and columns start at 1. There is a function that counts the number of empty spaces in the scaffold. It iterates through the scaffold and returns the number of vacant spaces by using the checkerAt function. The last function needed is the display function. This function interates through the scaffold and prints out the scaffold. Using | to designate walls. The scaffold is always printed with the lowest level on the bottom, so in the loop, the function prints the top level first and goes down. The scaffold class also has a move stack to allow for undoMove(). 
Player.cpp
  The player class is an abstract class made up of 3 inherited classes, the human player, bad player, and smart player. Each of these subclasses has to implement the abstract method chooseMove(). The human player implements it by prompting the user for a column number. If the column is a valid and has room to put a checker, the function returns that column. Otherwise, it prompts the user again. There is a while loop that checks this condition, so if the user continuously enters bad values, it keeps prompting until the user input is valid. The bad player move just picks the leftmost empty column and returns it. The smart player uses a function called determine best computer move to choose the column that the function returns. The implementation of the determine best computer move Is described above. The smartplayer class adds a class variable for the timer. This timer handles the time it takes to run the determineBestComputerMove function which often uses deep recursion to analyze the best move.
  The game class is the class that organizes the entire structure of this project. It handles the winning, turn taking, and displaying of the game. It has a function to check if the game is completed. This function calls isGameWon() to test if the game is over. It has a constructor that initializes the scaffold to a certain size. It has a member variable for the scaffold and two pointers to the players, one red and one black. It also has a class variable for the last column moved. The game class has a take turn function, which take the current players move from chooseMove() and makes the move in the scaffold. It then checks if the game is completed and returns true if the game is completed. The play function handles the main running of the game. It displays the scaffold and lets each player take their turn while the game is not over. Once the game is over, the function displays the scaffold and prints out the winner.
  My implementation of the smartPlayer::chooseMove() function calls a helper function determineBestComputerMove which does all of the work. There are actually two helper functions which are almost identical in code. The other one is determineBestHumanMove().  These call each other recursively to determine the best computer move possible. It starts by analyzing the base case which is that there is only one empty column to move into. At that point, the player has to move there and return the result of moving there. If someone won return that. Also, make the best move that column. If this case is not met, then there are multiple moves that you can make. So make a vector of the number of available columns in the scaffold. Using a for loop, go through each column and make a move there. Now check if moving there won. If so, return that result-depth. This accounts for why sooner wins are favored. The deeper a call is the more negative the return value will be in this case, and the computer wants to maximize the result value. Now, if no one won, find the next best possible human move by calling determineBestHumanMove(). After getting the best possible human move, add the result of making that move to the vector you made earlier to keep track of the outcomes. The index of the vector will be the column and the value there will be the result. Undo the move you just made, and repeat for the next possible move you can make.  After trying all the possible moves, if go through the outcomes vector and pick the largest result and make bestMove equal to the column corresponding to that result. Return the result. The determineBestHumanMove() function is basically identical in code. Except, the human move function picks the minimum result possible. And if a move wins right away, you return depth-result because it favors minimum results and father down the depth will make that number more positive. 
